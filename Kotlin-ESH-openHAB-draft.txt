// Rule, compact version

rule "My Wakeup" {
    triggers-when = { item["BedroomLight"].is(ON) && currentTime.isAfter(SUNRISE + 30.minutes) }
    retrigger-delay = { 23.hours }
    actions = {
        item["BedroomLight"].cmd(OFF)
        thing["Radio1"].channel["power"].cmd(ON)
        thing["Radio1"].channel["volume"].cmd(60.percent)
        thing["Radio1"].channel["station"].cmd("AltRock2")
    }
}

// Rule, advanced version, could be in same or different file
rule "My Kotlin Rule1" {
    //optional. 
    // this scheduling engine is implemented already
    enabled-when = { "Mon-Fri = 15:30-00:00, 00:00-06:30; Sat; Sun = 00:00-06:30" }
    //optional
    forbidden-when = { "Sun = 06:30-12:30, 15:30-18:30; Wed" }
    retrigger-delay = { 30.minutes }
    
    //optional aliases for site specific mappings and readability
    alias-item = mapOf(
        "Light1" to "very_very_long_item_name1",
        "Light2" to "very_very_long_item_name2"
    )
    
    alias-channel = mapOf( 
        "Door1" to "very:very:long:channel:uid1",
        "Motion1" to "very:very:long:channel:uid2"
    )
    
    alias-thing = mapOf(
        "MotionSensor1" to "very:very:long:thing:uid1"
    )
    
    //required
    // you may refer to item or channel by special maps called item and channel
    triggers-when = { thing["MotionSensor1"].goesOffline && !item["Light1"].is(ON) &&
        channel["Door1"].goes(from = CLOSED, to = OPEN) 
    }
    
    //optional
    // you may refer to item or channel by special map called device
    should-not-trigger-when = { device["Door1"].is(CLOSED) && device["Motion1"].is(OPEN) }
    
    // optional
    // continue when thing, item, channel not found or not ready. similar to bash's set -e
    continue-on-errors = { true }
    
    actions = {
        // actions go here. free form Kotlin script, with IDE autocomplete,
        // and some nice helpers available in the context
        val msg = "Intrusion alert, suspicious activity near ${device["Door1"].label}";
        // use a predefined function from standard ESH Kotlin extension
        sendUiNotification(msg)

        // actions on items channels things
        // device means ESH Item or Channel, thing means ESH Thing
        device["Light1"].cmd(ON)
        device["Light2"].cmd(ON)

        // handle collection based actions
        // sendSMS is Kotlin extension, defined in standard lib or by user lib on Java type such as Person
        systemConfig.emergencyPersonal.filter(it.name == "Jack" || it.name == "Kim").forEach { sendSMS(it.phone, msg) }

        // lookup and use OSGI service, with special systemService helper
        val jsonStore = systemService<StorageService>()
        var myStorage: Storage<Int> = jsonStore.getStorage("MyStore")
        var alertCount? = myStorage.get("AlertCount")

        // null safety made easy
        // if old alertCount found, increment it, else initialize with 1
        myStorage.put("AlertCount", alertCount?++:1) 
    }
}


// common setup, executed freshly before every test
common-test-setup {
    // thing, item, channel are maps of respective types, created automatically by framework
    thing["MotionSensor1"] = TestThing("MotionSensor1")
    item["Light1"] = TestItem("Light1", OnOffType)
    channel["Door1"] = TestChannel("Door1", OpenClosedType)
}

offline-test "Scenario1" {
    setup = {
        // test specific setup script
        println("Running Scenario1")
    }
    
    actions = {
        thing["MotionSensor1"].updateStatus(ThingStatus.ONLINE)
        item["Light1"].updateState(OnOffType.ON)
        channel["Door1"].updateState(OpenClosedType.CLOSED)
    }
    
    assert = {
        rule["My Kotlin Rule1"].isNotTriggered && rule["My Kotlin Rule2"].isNotTriggered
    }
}

offline-test "Scenario2" {
    setup = {
        // test specific setup script
        println("Running Scenario2")
    }
    
    actions = {
        thing["MotionSensor1"].updateStatus(OFFLINE)
        item["Light1"].updateState(ON)
        channel["Door1"].updateState(CLOSED)
        delay(0.5)
        channel["Door1"].updateState(OPEN)
    }
    
    assert {
        rule["My Kotlin Rule1"].isTriggered &&
        device["Light2"].is(ON) &&
        rule["My Kotlin Rule2"].isNotTriggered
    }
}
